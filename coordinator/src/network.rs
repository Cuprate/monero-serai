use std::{collections::HashMap, time::Duration, env, io};
use group::ff::PrimeField;
use message_box::{MessageBox, PublicKey};
use tokio::{sync::mpsc, signal::ctrl_c};
use serde::{Deserialize, Serialize};
use log::{error, info};
use futures::StreamExt;
use libp2p::{
  core::{upgrade},
  floodsub::{Floodsub, FloodsubEvent, Topic},
  identity::{self},
  mplex,
  noise::{Keypair, NoiseConfig, X25519Spec},
  swarm::NetworkBehaviourEventProcess,
  tcp::TcpConfig,
  NetworkBehaviour, PeerId, Swarm, Transport, Multiaddr,
};

use dns_lookup::lookup_host;
use crate::core::NetworkConfig;

// Represents the type of message being sent
#[derive(Serialize, Deserialize, Debug, Clone)]
pub enum MessageType {
  // State of connected peers
  State,
  // Pubkey Message
  Pubkey,
  // Message Box Secure Message
  Secure,
}

// A message or event generated by a peer
#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct NetworkMessage {
  // The type of message this is.
  pub message_type: MessageType,
  // The data contained within the message, represented as a vector of bytes.
  pub data: Vec<u8>,
  // The intended recipient of the message, a PeerId encoded as a string.
  pub addressee: Option<String>,
  // The sender of this message, PeerId encoded as a String
  pub source: String,
}

// Contains the current state connected peers
#[derive(Serialize, Deserialize, Debug)]
pub struct State {
  // The peers currently connected to the network.
  pub peers: HashMap<String, String>,
  pub peer_pubkeys: HashMap<String, String>,
  pub peer_encrypted_messages: HashMap<String, String>,
}

impl State {
  // Attempt to merge two states together.
  pub fn merge(&mut self, mut other: State) {
    // Merge peers.
    for (peer_id, peer_name) in other.peers.drain() {
      if !self.peers.contains_key(&peer_id) {
        info!("Connected with peer: {}", &peer_name);
        self.peers.insert(peer_id, peer_name);
      }
    }
  }

  // Attempt to collect the name of a peer, if the peer doesn't exist then the name
  // defaults to `anon`.
  pub fn get_peer_name(&self, peer: &String) -> String {
    self.peers.get(peer).unwrap_or(&String::from("anon")).to_string()
  }
}

// The network behavior for swarm.
#[derive(NetworkBehaviour)]
#[behaviour(event_process = true)]
struct NetworkConnection {
  floodsub: Floodsub,
  #[behaviour(ignore)]
  state: State,
  #[behaviour(ignore)]
  peer_id: String,
  #[behaviour(ignore)]
  responder: mpsc::UnboundedSender<NetworkMessage>,
}

// Fires event when a message is received.
impl NetworkBehaviourEventProcess<FloodsubEvent> for NetworkConnection {
  fn inject_event(&mut self, event: FloodsubEvent) {
    match event {
      FloodsubEvent::Message(raw_data) => {
        //Parse the message as bytes
        let deser = bincode::deserialize::<NetworkMessage>(&raw_data.data);
        if let Ok(message) = deser {
          if let Some(user) = &message.addressee {
            if *user != self.peer_id.to_string() {
              return; //Don't process messages not intended for us.
            }
          }

          match message.message_type {
            MessageType::State => {
              //info!("State Received!");
              let data: State = bincode::deserialize(&message.data).unwrap();
              self.state.merge(data);
            }
            MessageType::Pubkey => {
              //info!("Pubkey recieved!");
              let sender: String = self.state.get_peer_name(&raw_data.source.to_string());
              let pubkey = String::from_utf8_lossy(&message.data);
              //info!("{}: {}", sender, pubkey);
              self.state.peer_pubkeys.insert(sender, pubkey.to_string());
            }
            MessageType::Secure => {
              //info!("Secure Message recieved!");
              let sender: String = self.state.get_peer_name(&raw_data.source.to_string());
              let secure_message = String::from_utf8_lossy(&message.data);
              //info!("{}: {}", sender, secure_message);
              self.state.peer_encrypted_messages.insert(sender.to_owned(), secure_message.to_string());

              let reciever_name: String = self.state.get_peer_name(&self.peer_id);
              let pubkey_string = &self.state.peer_pubkeys.get(&sender).unwrap().to_string();
              let peer_pubkey = message_box::PublicKey::from_trusted_str(pubkey_string);
              let decoded_msg = decrypt_secure_msg(&reciever_name, &secure_message, peer_pubkey);
              info!("Secure Msg: {}", decoded_msg);
            }
          }
        } else {
          error!("Unable to decode message! Due to {:?}", deser.unwrap_err());
        }
      }
      FloodsubEvent::Subscribed { peer_id, topic: _ } => {
        // Send our state to new user
        // info!("Sending stage to {}", peer_id);
        let message: NetworkMessage = NetworkMessage {
          message_type: MessageType::State,
          data: bincode::serialize(&self.state).unwrap(),
          addressee: Some(peer_id.to_string()),
          source: self.peer_id.to_string(),
        };
        send_response(message, self.responder.clone());
      }
      FloodsubEvent::Unsubscribed { peer_id, topic: _ } => {
        let name = self.state.peers.remove(&peer_id.to_string()).unwrap_or(String::from("Anon"));
        info!("Disconnect from {}", name);
      }
    }
  }
}

// Network Process contains our peer's name, address, & address book for other peers.
#[derive(Clone, Debug, Deserialize)]
pub struct NetworkProcess {
  name: String,
  address: String,
  address_book: HashMap<String, String>,
}

impl NetworkProcess {
  // Retrieves IP address of current hostname & other hostnames from config file.
  pub fn new(name: String, address_book: Vec<config::Value>) -> Self {
    info!("New Network Process");

    let mut hostname = "".to_string();
    hostname.push_str("coordinator-");
    hostname.push_str(&name);
    let ips: Vec<std::net::IpAddr> = lookup_host(&hostname).unwrap();
    let ip = ips[0].to_string();

    let mut address_ref = "/ip4/".to_string();
    address_ref.push_str(ip.as_str());
    address_ref.push_str("/tcp/8080");

    let mut address_book_ref: HashMap<String, String> = HashMap::new();

    for address in address_book {
      let name_ref = address.into_string().unwrap();
      if name_ref != name {
        let hostname_ref = format!("coordinator-{}", &name_ref);
        let ips_ref_result = lookup_host(&hostname_ref);
        if !ips_ref_result.is_err() {
          let ips_ref = ips_ref_result.unwrap();
          let ip_ref = ips_ref[0].to_string();

          let mut address_string = "/ip4/".to_string();
          address_string.push_str(ip_ref.as_str());
          address_string.push_str("/tcp/8080");

          //println!("{}: {}", &name_ref, &address_string);
          address_book_ref.insert(name_ref, address_string);
        }
      }
    }

    Self { name, address: address_ref, address_book: address_book_ref }
  }

  // Runs network process & listens for events.
  pub async fn run(self) {
    info!("Starting Network Process");

    // Initialize Pub/Priv key pair
    initialize_keys(&self.name);

    let id_keys = identity::Keypair::generate_ed25519();
    let peer_id = PeerId::from(id_keys.public());

    let auth_keys = Keypair::<X25519Spec>::new()
      .into_authentic(&id_keys)
      .expect("unable to create authenticated keys");

    let transport = TcpConfig::new()
      .upgrade(upgrade::Version::V1)
      .authenticate(NoiseConfig::xx(auth_keys).into_authenticated())
      .multiplex(mplex::MplexConfig::new())
      .boxed();

    // Generate channel
    let (response_sender, mut response_rcv) = mpsc::unbounded_channel();

    let mut behaviour = NetworkConnection {
      floodsub: Floodsub::new(peer_id),
      state: State {
        peers: HashMap::from([(peer_id.to_string(), self.name.to_string())]),
        peer_pubkeys: HashMap::new(),
        peer_encrypted_messages: HashMap::new(),
      },
      peer_id: peer_id.to_string(),
      responder: response_sender,
    };

    let topic = Topic::new("coordinator");
    behaviour.floodsub.subscribe(topic.clone());

    let mut swarm = Swarm::new(transport, behaviour, peer_id);
    let listening_address: Multiaddr = self.address.parse().unwrap();
    swarm.listen_on(listening_address).unwrap();

    for (name, address) in self.address_book {
      let address_ref = address.parse::<Multiaddr>().unwrap();
      // info!("Dialing {} at {}", &name, &address_ref);
      swarm.dial(address_ref).unwrap();
    }

    loop {
      tokio::select! {
        _ = network_tick() => {
          // This tick is used to trigger sending messages after a connection is established
          // Sending messages immdediatly after connection is established without a tick causes the messages to be dropped

          // Check if we need to communicate pubkey to new peers
          if &swarm.behaviour_mut().state.peers.len() > &swarm.behaviour_mut().state.peer_pubkeys.len() {
            let peers = swarm.behaviour_mut().state.peers.clone();
            let peer_pubkeys = swarm.behaviour_mut().state.peer_pubkeys.clone();
            for (peer_id, name) in peers {
              if !peer_pubkeys.contains_key(&name) {
                let receiver_pub_key = &mut self.name.to_string().to_uppercase();
                receiver_pub_key.push_str("_PUB");

                let msg = &env::var(receiver_pub_key).unwrap().to_string();

                let message = NetworkMessage {
                  message_type: MessageType::Pubkey,
                  data: msg.as_bytes().to_vec(),
                  addressee: Some(peer_id.to_string()),
                  source: peer_id.to_string(),
                };
                send_message(&message, &mut swarm, &topic);
              }
            }
          }

          // If we have a pubkey without encyrpyted message, send the message
          let peer_pubkeys = swarm.behaviour_mut().state.peer_pubkeys.clone();
          let peer_encrypted_messages = swarm.behaviour_mut().state.peer_encrypted_messages.clone();

          for (name, pubkey) in peer_pubkeys {
            if !peer_encrypted_messages.contains_key(&name) {
              // Retrieves peer_id from peer name
              let peers = swarm.behaviour_mut().state.peers.clone();
              let mut peer_id = String::new();
              for (id, peer_name) in peers {
                if peer_name == name {
                  peer_id = id;
                }
              }

              let peer_pub = message_box::PublicKey::from_trusted_str(&pubkey);
              let raw_message = format!("{} to {}", &self.name, &name);

              let msg = build_secure_msg(&self.name.to_string(), peer_pub, &raw_message);

              let message = NetworkMessage {
                message_type: MessageType::Secure,
                data: msg.as_bytes().to_vec(),
                addressee: Some(peer_id),
                source: self.name.to_string(),
              };
              send_message(&message, &mut swarm, &topic);
            }
          }
        }
        event = swarm.select_next_some() => {
                //println!("Swarm event: {:?}", &event);
                match event {
                  libp2p::swarm::SwarmEvent::Behaviour(_) => {
                    info!("Behavior Event");
                  }
                  libp2p::swarm::SwarmEvent::ConnectionEstablished { peer_id, endpoint, num_established, concurrent_dial_errors } => {
                    info!("Connection Established");
                    swarm.behaviour_mut().floodsub.add_node_to_partial_view(peer_id);
                  },
                  libp2p::swarm::SwarmEvent::ConnectionClosed { peer_id, endpoint, num_established, cause } => {
                    info!("Connection Closed");
                    swarm.behaviour_mut().floodsub.remove_node_from_partial_view(&peer_id);
                  }
                  libp2p::swarm::SwarmEvent::IncomingConnection { local_addr, send_back_addr } => {
                    info!("Incoming Connection");
                  }
                  libp2p::swarm::SwarmEvent::IncomingConnectionError { local_addr, send_back_addr, error } => {
                    info!("Incoming Error");
                  }
                  libp2p::swarm::SwarmEvent::OutgoingConnectionError { peer_id, error } => {
                    info!("Outgoing Connection Error");
                  }
                  libp2p::swarm::SwarmEvent::BannedPeer { peer_id, endpoint } => {
                    info!("Banned Peer");
                  }
                  libp2p::swarm::SwarmEvent::NewListenAddr { listener_id, address } => {
                    info!("New Listen Addr");
                  }
                  libp2p::swarm::SwarmEvent::ExpiredListenAddr { listener_id, address } => {
                    info!("Expired Listen Addr");
                  }
                  libp2p::swarm::SwarmEvent::ListenerClosed { listener_id, addresses, reason } => {
                    info!("Listener Closed");
                  }
                  libp2p::swarm::SwarmEvent::ListenerError { listener_id, error } => {
                    info!("Listener Error");
                  },
                  libp2p::swarm::SwarmEvent::Dialing(_) => {
                    info!("Dialing");
                  }
                }
        },
        response = response_rcv.recv() => {
            if let Some(message) = response {
                send_message(&message, &mut swarm, &topic);
            }
        },
        event = ctrl_c() => {
            if let Err(e) = event {
                info!("Failed to register interrupt handler {}", e);
            }
            break;
        }
      }
    }

    io::stdin().read_line(&mut String::new()).unwrap();
  }

  fn stop(self) {
    info!("Stopping Network Process");
  }
}

async fn network_tick() {
  tokio::time::sleep(Duration::from_millis(1000)).await;
}

fn send_response(message: NetworkMessage, sender: mpsc::UnboundedSender<NetworkMessage>) {
  tokio::spawn(async move {
    if let Err(e) = sender.send(message) {
      error!("error sending response via channel {}", e);
    }
  });
}

/// Send a message using the swarm
fn send_message(message: &NetworkMessage, swarm: &mut Swarm<NetworkConnection>, topic: &Topic) {
  let bytes = bincode::serialize(message).unwrap();
  swarm.behaviour_mut().floodsub.publish(topic.clone(), bytes);
}

// Generates Private / Public key pair
fn initialize_keys(name: &str) {
  // Checks if coordinator keys are set
  let mut env_priv_key = name.to_string();
  env_priv_key = env_priv_key.to_uppercase();
  env_priv_key.push_str("_PRIV");

  let coord_priv_check = env::var(env_priv_key);
  if coord_priv_check.is_err() {
    //info!("Generating New Keys");
    // Generates new private / public key
    let (private, public) = message_box::key_gen();
    let private_bytes = unsafe { private.inner().to_repr() };

    let mut env_priv_key = name.to_string();
    env_priv_key = env_priv_key.to_uppercase();
    env_priv_key.push_str("_PRIV");

    let mut env_pub_key = name.to_string();
    env_pub_key = env_pub_key.to_uppercase();
    env_pub_key.push_str("_PUB");

    // Sets private / public key to environment variables
    env::set_var(env_priv_key, hex::encode(&private_bytes.as_ref()));
    env::set_var(env_pub_key, hex::encode(&public.to_bytes()));
  }
}

// Build secure message
fn build_secure_msg(sender_name: &str, receiver_pubkey: PublicKey, msg: &str) -> String {
  let mut sender_pub_key = sender_name.to_string();
  sender_pub_key = sender_pub_key.to_uppercase();
  sender_pub_key.push_str("_PUB");

  let pubkey_string = env::var(sender_pub_key).unwrap().to_string();
  let sender_pub = message_box::PublicKey::from_trusted_str(&pubkey_string);

  let mut sender_priv_key = sender_name.to_string();
  sender_priv_key = sender_priv_key.to_uppercase();
  sender_priv_key.push_str("_PRIV");

  let sender_priv =
    message_box::PrivateKey::from_string(env::var(sender_priv_key).unwrap().to_string());

  let mut message_box_pubkey = HashMap::new();
  message_box_pubkey.insert(receiver_pubkey, receiver_pubkey);

  let message_box = MessageBox::new(sender_pub, sender_priv, message_box_pubkey);
  return message_box.encrypt_to_string(&receiver_pubkey, &msg.clone());
}

// Decrypt secure message
fn decrypt_secure_msg(receiver_name: &str, secured_msg: &str, sender_pubkey: PublicKey) -> String{
  let mut receiver_pub_key = receiver_name.to_string();
  receiver_pub_key = receiver_pub_key.to_uppercase();
  receiver_pub_key.push_str("_PUB");

  let pubkey_string = env::var(receiver_pub_key).unwrap().to_string();
  let receiver_pub = message_box::PublicKey::from_trusted_str(&pubkey_string);

  let mut receiver_priv_key = receiver_name.to_string();
  receiver_priv_key = receiver_priv_key.to_uppercase();
  receiver_priv_key.push_str("_PRIV");

  let receiver_priv =
    message_box::PrivateKey::from_string(env::var(receiver_priv_key).unwrap().to_string());

  let mut message_box_pubkey = HashMap::new();
  message_box_pubkey.insert(sender_pubkey, sender_pubkey);

  let message_box = MessageBox::new(receiver_pub, receiver_priv, message_box_pubkey);
  return message_box.decrypt_from_str(&sender_pubkey, &secured_msg.clone()).unwrap();
}
